🧩 PATRÓN UX LES · ATRIBUTOS CONDICIONALES (C)Nombre oficial:LES-UX-PATTERN-C · Conditional Attribute HandlingÁmbito:Wizard de altaFicha de ediciónFicha de consulta (solo lectura)Fuente normativa:Anexo C (Atributos por Subcategoría)SR-03 (Motor de reglas)SR-04 (Validación de guardado)1️⃣ Principio rector (no negociable)La UX no decide si un atributo condicional se muestra, se oculta o es obligatorio.La UX solo representa el resultado del motor de reglas.La única fuente de verdad es el resultado de:ComputeEffectiveAttributeRules()con estos flags finales por atributo:is_applicableis_visibleis_requiredis_readonly (si aplica)2️⃣ Estados UX posibles de un atributo (tabla normativa)Estado lógicoVisibleEditableObligatorioUX permitidoNA❌❌❌No renderizarO✅✅✅Campo normal con *OP✅✅❌Campo opcionalC (inactivo)✅❌❌Campo visible deshabilitado + hintC (activo)✅✅✅Campo normal con *⚠️ Nunca ocultar un condicional aplicable⚠️ Nunca permitir editar un condicional inactivo3️⃣ Regla clave del patrón (decisión más importante)❗ Atributos C SIEMPRE son visibles cuando son aplicablesIncluso cuando:no son obligatoriosno están activos aún👉 Esto evita:sorpresas al usuarioaparición “mágica” de camposerrores de guardado incomprensibles4️⃣ Comportamiento detallado por estado🟡 C — Inactivo (condición no cumplida)Estado funcionalis_applicable = trueis_visible = trueis_required = falseis_readonly = trueRepresentación UXCampo visibleDeshabilitadoEstilo visual atenuadoTooltip / helper fijo explicativoTexto estándar LES (no libre):“Este campo se activará cuando se cumpla la condición correspondiente.”(Opcional: tooltip ampliado con “Depende de: [atributo X]” si está definido)🔴 C — Activo (condición cumplida)Estado funcionalis_applicable = trueis_visible = trueis_required = trueis_readonly = falseRepresentación UXCampo editableMarcado como obligatorio (*)Validación activaTexto de error estándar (si falta valor):“Este campo es obligatorio según las características seleccionadas.”⚪ NA — No aplicableEstado funcionalis_applicable = falseRepresentación UX❌ No se renderiza❌ No se guarda❌ No se valida⚠️ NA nunca deja rastro visible en UX⚠️ NA nunca genera error5️⃣ Comportamiento en Wizard de AltaPaso 1 — Selección de categoría/subcategoríaSe renderizan:OOPC (inactivos)NA no aparecePaso 2 — Introducción de valoresCada cambio de valor:dispara recalculo del motor SR-03puede activar/desactivar CPaso 3 — ConfirmaciónAntes de permitir “Finalizar”:Ejecutar validación SR-04Si algún C activo obligatorio no está informado:bloquear avancemostrar errores de campo6️⃣ Comportamiento en Ficha de EdiciónMisma lógica que wizardDiferencia:Los valores previos ya existenAl cambiar un valor “gatillo”, otros C pueden:activarse (y volverse obligatorios)desactivarse (y quedar readonly)⚠️ Nunca borrar automáticamente valores existentesSi un atributo pasa de C activo → inactivo:queda visiblequeda deshabilitadoel valor se conservano participa en validación7️⃣ Comportamiento en Ficha de Consulta (solo lectura)Renderizar:OOPC (activo o inactivo)NA no se muestraEstilo:C inactivo: gris + nota “No aplicable actualmente”C activo: visible normal👉 Esto refuerza comprensión del modelo por parte del usuario.8️⃣ Mensajes UX normados (no creativos)SituaciónMensajeC inactivo“Este campo se activará cuando se cumpla la condición correspondiente.”C activo sin valor“Este campo es obligatorio según las características seleccionadas.”Intento de edición C inactivo“Este campo no es editable en el estado actual.”9️⃣ Reglas explícitas de prohibición🚫 No ocultar C aplicables🚫 No activar C sin recalcular reglas🚫 No permitir guardado si C activo obligatorio está vacío🚫 No decidir en frontend qué es obligatorio🚫 No duplicar lógica de reglas en UI🔒 Resultado de este patrónCon este patrón:La UX refleja exactamente Anexo CEl usuario entiende por qué algo es obligatorioEl frontend no interpreta reglasEl backend valida de forma coherenteEl sistema es auditable y gobernableEste patrón es LES-wide, no solo Inventario.
