Fase A0 — Matriz Fuente → Objeto técnico (arranque)Decisión funcional (normativa)Inventario es troncal y cada pieza existe una única vez con ID no reutilizable, y se identifica además con Código + QR derivados del ID. 02-01 - DOCUMENTO RF01-01 - FRaD_Modulo_Inventario_…La ficha completa incluye estado operativo, ubicación, clasificación, atributos y movimientos. 02-01 - DOCUMENTO RF“Código interno” y “QR” existen como atributos comunes del catálogo (Anexo B). 01-02 - FRaD - Anexo B - Atribu…Implicación técnica (regla de traducción)Todo objeto técnico (tabla/campo/constraint) debe tener trazabilidad a:RF (RF-INV-xxx) y/o FRaD,y/o Anexo A–D cuando aplique.No duplicar semántica: si un dato es “identificación troncal” pero también aparece como “atributo común”, se modela como:campo troncal en InventoryItem (por integridad y trazabilidad),y mapeo lógico a su definición de atributo (para que la ficha dinámica siga siendo “construida desde el catálogo”). 01-02 - FRaD - Anexo B - Atribu…01-01 - FRaD_Modulo_Inventario_…Entregable A0 (v0.1): ejemplo de matriz mínima (núcleo)Objeto técnicoTipoFuente normativaRegla / IntenciónInventoryItem.ItemIdPKRF-INV-002 + FRaD 4.1ID único no reutilizable 02-01 - DOCUMENTO RF01-01 - FRaD_Modulo_Inventario_…InventoryItem.ItemCodeUniqueRF-INV-011 + FRaD 4.1 + Anexo B (Código interno)Código visible autogenerado / parametrizable 02-01 - DOCUMENTO RF01-01 - FRaD_Modulo_Inventario_…01-02 - FRaD - Anexo B - Atribu…InventoryItem.QRValueUniqueRF-INV-012 + FRaD 4.1 + Anexo B (QR)QR autogenerado asociado al ID 02-01 - DOCUMENTO RF01-01 - FRaD_Modulo_Inventario_…01-02 - FRaD - Anexo B - Atribu…InventoryItem.OperationalStatusIdFKRF-INV-020/021 + Anexo D (Dominio Estado Operativo)Un único estado operativo activo 02-01 - DOCUMENTO RF01-02 - FRaD - Anexo D - Domini…InventoryItem.LocationIdFKFRaD 4.2 + Anexo D (Dominio Ubicación)Ubicación obligatoria siempre 01-01 - FRaD_Modulo_Inventario_…01-02 - FRaD - Anexo D - Domini…InventoryItem.CategoryId/SubcategoryIdFKFRaD 4.2 + Anexo AClasificación obligatoria; gobierna ficha dinámica 01-01 - FRaD_Modulo_Inventario_…01-02 - FRaD - Anexo A - Clasif…InventoryItem.CreatedAt/CreatedByAuditFRaD 4.2 + principio trazabilidadAuditoría mínima obligatoria 01-01 - FRaD_Modulo_Inventario_…Constraint “no change status/location without movement”ReglaRF-INV-041No permitir cambio sin movimiento (se implementa en Fase A7) 02-01 - DOCUMENTO RFFase A1 — Núcleo troncal (ERD v0 + diccionario mínimo + reglas)Decisión funcional (normativa)Entidad troncal: Pieza (Inventory Item), única, multi-tienda; gobierna ciclo de vida y se reutiliza en módulos conectados. 01-01 - FRaD_Modulo_Inventario_…Identificación obligatoria: ItemId (único) + ItemCode + QRValue. 02-01 - DOCUMENTO RF01-01 - FRaD_Modulo_Inventario_…La pieza debe tener un único estado operativo activo y ubicación actual obligatoria. 02-01 - DOCUMENTO RF01-01 - FRaD_Modulo_Inventario_…Implicación técnica (modelo mínimo “sin interpretación”)ERD v0 (núcleo estrictamente necesario)Tablas:InventoryItem (Pieza)OperationalStatus (Catálogo de estados operativos configurables)Location (Catálogo de ubicaciones configurables)AppUser (referencia mínima para auditoría CreatedBy/UpdatedBy)Relaciones (cardinalidades):OperationalStatus (1) ── (N) InventoryItem (cada pieza tiene 1 estado activo; un estado aplica a muchas piezas). 02-01 - DOCUMENTO RFLocation (1) ── (N) InventoryItem (cada pieza tiene 1 ubicación activa). 01-01 - FRaD_Modulo_Inventario_…AppUser (1) ── (N) InventoryItem vía CreatedBy y UpdatedBy.Nota de encaje con Anexo B: “Código interno” y “QR” están en el catálogo de atributos comunes, pero aquí se materializan como campos troncales por ser parte de la identidad y trazabilidad (y se mapearán al catálogo en A3/A6, sin duplicar significado). 01-02 - FRaD - Anexo B - Atribu…01-01 - FRaD_Modulo_Inventario_…Diccionario de datos mínimo (A1)1) InventoryItemCampoTipo sugeridoNuloConstraintFuente normativaItemIdUUID / BIGINTNoPK, no reutilizableRF-INV-002, FRaD 4.1 02-01 - DOCUMENTO RF01-01 - FRaD_Modulo_Inventario_…ItemCodeVARCHARNoUNIQUERF-INV-011, FRaD 4.1, Anexo B “Código interno” 02-01 - DOCUMENTO RF01-01 - FRaD_Modulo_Inventario_…01-02 - FRaD - Anexo B - Atribu…QRValueVARCHARNoUNIQUERF-INV-012, FRaD 4.1, Anexo B “QR” 02-01 - DOCUMENTO RF01-01 - FRaD_Modulo_Inventario_…01-02 - FRaD - Anexo B - Atribu…OperationalStatusIdFKNoFK→OperationalStatusRF-INV-020/021 + Dominio Estado Operativo 02-01 - DOCUMENTO RF01-02 - FRaD - Anexo D - Domini…LocationIdFKNoFK→LocationFRaD “Ubicación obligatoria siempre” + Dominio Ubicación 01-01 - FRaD_Modulo_Inventario_…01-02 - FRaD - Anexo D - Domini…LastMovementAtDATETIMESí*(se alimenta por movimientos)Anexo B “Fecha último movimiento” 01-02 - FRaD - Anexo B - Atribu…CreatedAtDATETIMENodefault NOWFRaD 4.2 trazabilidad 01-01 - FRaD_Modulo_Inventario_…CreatedByUserIdFKNoFK→AppUserFRaD 4.2 trazabilidad 01-01 - FRaD_Modulo_Inventario_…UpdatedAtDATETIMENodefault NOWFRaD 4.2 trazabilidad 01-01 - FRaD_Modulo_Inventario_…UpdatedByUserIdFKNoFK→AppUserFRaD 4.2 trazabilidad 01-01 - FRaD_Modulo_Inventario_…* LastMovementAt en A1 puede quedar nullable; se vuelve “siempre informado” cuando activemos movimientos (Fase A7) según RF-INV-040/042. 02-01 - DOCUMENTO RF2) OperationalStatusOperationalStatusId (PK)Name (UNIQUE)Valores iniciales (configurables): Controlada, Disponible, Reservada/Apartada, En reparación/personalización, En tránsito, Bloqueada, Lista para entrega, Vendida (cerrada), Ajuste/regularización. 02-01 - DOCUMENTO RF01-02 - FRaD - Anexo D - Domini…3) LocationLocationId (PK)Name (UNIQUE)IsSemiClosed (para gobernar “semi-cerrado” en evolución)Valores base: Tienda, Almacén, Taller externo, En tránsito (dominio semi-cerrado). 01-02 - FRaD - Anexo D - Domini…4) AppUserUserId (PK)Role (Administrador / Dependienta) mínimo para auditoría (la matriz de permisos se desarrolla fuera de A1). 01-01 - FRaD_Modulo_Inventario_…Reglas de integridad “duras” (A1)R1 — Unicidad de piezaNo pueden existir dos piezas activas con el mismo ItemId. (PK)No pueden existir dos piezas con el mismo ItemCode o el mismo QRValue. (UNIQUE) 02-01 - DOCUMENTO RF01-01 - FRaD_Modulo_Inventario_…R2 — Estado y ubicación obligatoriosOperationalStatusId NOT NULL y FK válida.LocationId NOT NULL y FK válida. 02-01 - DOCUMENTO RF01-01 - FRaD_Modulo_Inventario_…R3 — Auditoría mínima obligatoriaCreatedAt/CreatedBy y UpdatedAt/UpdatedBy siempre informados. 01-01 - FRaD_Modulo_Inventario_…Impacto UX (solo el mínimo derivado, sin diseñar pantallas)En alta de pieza, identificación (ItemCode, QRValue) se genera automáticamente y se muestra como “solo lectura”. No puede existir “pieza sin estado” ni “pieza sin ubicación”: el wizard debe forzar ambos antes de guardar. Fase A2 — Clasificación normada (Categorías / Subcategorías) + FKs en PiezaDecisión funcional (normativa)Una pieza pertenece a una única Categoría y una única Subcategoría. 01-02 - FRaD - Anexo A - Clasif…La Categoría define el tipo físico general y la Subcategoría define la tipología dentro de esa categoría. 01-02 - FRaD - Anexo A - Clasif…01-01 - FRaD_Modulo_Inventario_…CategoryId/SubcategoryId son obligatorios en la entidad troncal Pieza y gobiernan la ficha dinámica (y el wizard de alta). 01-01 - FRaD_Modulo_Inventario_…02-01 - DOCUMENTO RFEl sistema debe permitir CRUD de Categorías y Subcategorías y su asociación. 02-01 - DOCUMENTO RF02-02 - UX-UI · Wireframes func…Implicación técnica1) Tablas de catálogo (clasificación)CategoryCampoTipo sugeridoNuloConstraintFuenteCategoryIdUUID/BIGINTNoPKAnexo A + RF-INV-030 01-02 - FRaD - Anexo A - Clasif…02-01 - DOCUMENTO RFNameVARCHARNoUNIQUEAnexo A 01-02 - FRaD - Anexo A - Clasif…DescriptionTEXTSí—Anexo A (definiciones) 01-02 - FRaD - Anexo A - Clasif…IsActiveBOOLNodefault trueGobierno (evitar borrado físico)CreatedAt/ByauditNo—FRaD trazabilidad 01-01 - FRaD_Modulo_Inventario_…SubcategoryCampoTipo sugeridoNuloConstraintFuenteSubcategoryIdUUID/BIGINTNoPKAnexo A + RF-INV-031 01-02 - FRaD - Anexo A - Clasif…02-01 - DOCUMENTO RFCategoryIdFKNoFK→CategoryAnexo A (subcategoría depende de categoría) 01-02 - FRaD - Anexo A - Clasif…NameVARCHARNoUNIQUE (ver nota)Anexo A 01-02 - FRaD - Anexo A - Clasif…DescriptionTEXTSí—Anexo A 01-02 - FRaD - Anexo A - Clasif…IsActiveBOOLNodefault trueGobiernoCreatedAt/ByauditNo—FRaD trazabilidad 01-01 - FRaD_Modulo_Inventario_…Nota (decisión técnica, sin cambiar lo funcional):Para evitar ambigüedad futura, la unicidad recomendable es:UNIQUE(CategoryId, Name) en Subcategory (una misma subcategoría no puede repetirse dentro de una categoría).Esto respeta el Anexo A (subcategorías están definidas dentro de categorías). 01-02 - FRaD - Anexo A - Clasif…2) Integración en la entidad troncal InventoryItemSe amplía InventoryItem con los FKs ya definidos como “mínimos recomendados”. 01-01 - FRaD_Modulo_Inventario_…CampoTipoNuloConstraintFuenteCategoryIdFKNoFK→CategoryFRaD 4.2 + Anexo A 01-01 - FRaD_Modulo_Inventario_…01-02 - FRaD - Anexo A - Clasif…SubcategoryIdFKNoFK→SubcategoryFRaD 4.2 + Anexo A 01-01 - FRaD_Modulo_Inventario_…01-02 - FRaD - Anexo A - Clasif…3) Reglas de integridad específicas de clasificaciónR4 — Obligatoriedad de clasificaciónInventoryItem.CategoryId NOT NULLInventoryItem.SubcategoryId NOT NULL 01-01 - FRaD_Modulo_Inventario_…02-01 - DOCUMENTO RFR5 — Consistencia Category ↔ Subcategory (regla crítica)No basta con dos FKs separados: el sistema debe impedir que una pieza tenga:CategoryId = Anillos y SubcategoryId = Pendientes de aro (inconsistencia).Implementación técnica (sin interpretación):Constraint compuesto (recomendado):Asegurar que InventoryItem.(CategoryId, SubcategoryId) referencia una tabla puente única CategorySubcategory.Alternativa: trigger / constraint lógico que valide que Subcategory.CategoryId == InventoryItem.CategoryId.✅ La opción más robusta y “sin interpretación” es introducir explícitamente la relación normada.Entregable A2 (modelo lógico recomendado)Tabla puente explícita: CategorySubcategoryEsto convierte la regla del Anexo A en una regla de integridad “de base de datos”.CampoTipoNuloConstraintFuenteCategoryIdFKNoFK→CategoryAnexo A 01-02 - FRaD - Anexo A - Clasif…SubcategoryIdFKNoFK→SubcategoryAnexo A 01-02 - FRaD - Anexo A - Clasif…(PK compuesto)——PK(CategoryId, SubcategoryId)IntegridadIsActiveBOOLNodefault trueGobiernoY entonces, en InventoryItem:Reemplazar FKs separados por un FK compuesto:FK (CategoryId, SubcategoryId) → CategorySubcategory(CategoryId, SubcategoryId)Resultado: Consistencia garantizada a nivel de integridad, sin necesidad de lógica adicional.Impacto UX (solo derivado)En el alta/edición:se elige Categoríael sistema filtra Subcategorías válidas para esa categoría (no se puede elegir una inválida). 01-02 - FRaD - Anexo A - Clasif…Si se cambia Subcategoría en una pieza existente, el sistema deberá revalidar atributos (esto se implementa en A5/A6 con Anexo C). 01-02 - FRaD - Anexo C - Defini…Estado del modelo tras A2 (resumen)Ya tenemos un núcleo implementable:InventoryItem con Identificación + Estado + Ubicación + Clasificación. 01-01 - FRaD_Modulo_Inventario_…Catálogos: Category, Subcategory, (y recomendado) CategorySubcategory. 01-02 - FRaD - Anexo A - Clasif…Reglas duras de integridad: obligatoriedad + consistencia category-subcategory.Fase A3 — Catálogo global de atributos (Attribute) según Anexo BDecisión funcional (normativa)Existe un catálogo global de atributos comunes reutilizables: “un atributo se define una sola vez y se reutiliza”. 01-02 - FRaD - Anexo B - Atribu…Este anexo NO asigna atributos a subcategorías ni define obligatoriedad; eso pertenece al Anexo C. 01-02 - FRaD - Anexo B - Atribu…Los atributos pueden ser de tipo Texto, Número, Booleano, Lista, Rango y si son Lista deben referenciar un dominio (Anexo D). 01-02 - FRaD - Anexo B - Atribu…01-02 - FRaD - Anexo D - Domini…La ficha de pieza se construye exclusivamente a partir de este catálogo (prohibido ad-hoc). 01-02 - FRaD - Anexo B - Atribu…Implicación técnica1) Tabla Attribute (metamodelo de atributos)Objetivo: representar cada atributo como definición única, versionable y enlazable a dominios.AttributeCampoTipo sugeridoNuloConstraintFuenteAttributeIdUUID/BIGINTNoPKAnexo B (definición única) 01-02 - FRaD - Anexo B - Atribu…NameVARCHARNoUNIQUEAnexo B “Nombre atributo” (identificador funcional único) 01-02 - FRaD - Anexo B - Atribu…DescriptionTEXTSí—Anexo B 01-02 - FRaD - Anexo B - Atribu…DataTypeENUMNo(TEXT, NUMBER, BOOLEAN, LIST, RANGE, DATE)Anexo B tipos de dato 01-02 - FRaD - Anexo B - Atribu…DomainIdFKSíFK→Domain (solo si DataType=LIST)Anexo B + Anexo D (listas controladas) 01-02 - FRaD - Anexo B - Atribu…01-02 - FRaD - Anexo D - Domini…IsReusableBOOLNodefault trueAnexo B “Reutilizable siempre SÍ” 01-02 - FRaD - Anexo B - Atribu…IsActiveBOOLNodefault trueGobierno (evitar borrado físico)CreatedAt/ByauditNo—FRaD trazabilidad 01-01 - FRaD_Modulo_Inventario_…Reglas duras (DB/service):R6: Name único global (no duplicidad semántica). 01-02 - FRaD - Anexo B - Atribu…R7: si DataType = LIST entonces DomainId NOT NULL; si no es LIST entonces DomainId NULL. (integridad) 01-02 - FRaD - Anexo D - Domini…R8: No se permite crear atributos “derivados por material” (ej. “Material oro”) porque el modelo obliga a usar atributo + dominio. 01-02 - FRaD - Anexo B - Atribu…Nota: incluyo DATE porque el anexo contiene atributos de fecha (“Fecha de alta”, “Fecha último movimiento”). 01-02 - FRaD - Anexo B - Atribu…01-02 - FRaD - Anexo B - Atribu…2) Proyección del catálogo Anexo B a Attribute (muestra representativa)No voy a “transcribir todo” aquí aún (lo haremos cuando armemos el inventario completo), pero sí dejo claro el mapeo con ejemplos inequívocos del anexo:Identificación y control: “Código interno” (TEXT), “QR” (TEXT), “Origen de la pieza” (LIST → Dominio Origen), “Fecha de alta” (DATE), “Estado legal” (LIST → Dominio Estado legal). 01-02 - FRaD - Anexo B - Atribu…01-02 - FRaD - Anexo D - Domini…Materiales: “Material principal” (LIST → Dominio Material), “Ley / quilataje metal” (LIST → Dominio Quilataje), “Color del metal” (LIST → Dominio Color del metal), “Peso total” (NUMBER). 01-02 - FRaD - Anexo B - Atribu…01-02 - FRaD - Anexo D - Domini…Personalización: “Grabado” (BOOLEAN) y “Texto grabado” (TEXT) existen como atributos separados (la condición “solo si Grabado=Sí” se aplica en Anexo C, Fase A5). 01-02 - FRaD - Anexo B - Atribu…01-02 - FRaD - Anexo B - Atribu…Impacto UX (mínimo, derivado)En pantallas de configuración (Admin), el usuario podrá gestionar:catálogo de atributos (RF-INV-032),y vincular dominios cuando proceda (RF-INV-034/035). 02-01 - DOCUMENTO RF02-04 - MATRIZ PANTALLAEn ficha de pieza, aún no se decide qué atributos se muestran: eso vendrá con A5 (Anexo C) y el requisito de ficha dinámica. 02-01 - DOCUMENTO RF01-02 - FRaD - Anexo B - Atribu…Checklist de coherencia LES (para evitar silos)Dato nace una vez: el atributo se define 1 vez en Attribute y se reutiliza en todas las subcategorías. 01-02 - FRaD - Anexo B - Atribu…No ad-hoc: prohibidos campos “locales” fuera del catálogo de atributos. 01-02 - FRaD - Anexo B - Atribu…Dominios controlan listas: no hay listas manuales sueltas en UI ni en BD. 01-02 - FRaD - Anexo D - Domini…Siguiente fase (A4)Fase A4 — Dominios y valores controlados: tablas Domain y DomainValue + reglas de semi-cerrados (justificación y auditoría), enlazando directamente con los atributos DataType=LIST. 01-02 - FRaD - Anexo D - Domini…01-02 - FRaD - Anexo D - Domini…Fase A4 — Dominios y valores controlados (Anexo D) + reglas semi-cerradosDecisión funcional (normativa)Todo atributo tipo LISTA se alimenta de un Dominio definido en el Anexo D (valores controlados).Existen dominios cerrados (solo valores predefinidos) y semi-cerrados (permiten añadir valores, pero con control y trazabilidad, incluyendo justificación obligatoria y aprobación/registro).No se permiten “listas libres” sin gobierno: los valores deben provenir del dominio correspondiente.El Anexo D define también dominios operativos troncales (p.ej. Ubicación, Estado Operativo, Estado legal, etc.), que se reutilizan en todo el LES.Implicación técnica1) Modelo lógico de dominios (catálogo troncal)DomainCampoTipo sugeridoNuloConstraintFuenteDomainIdUUID/BIGINTNoPKAnexo DCodeVARCHARNoUNIQUEIdentificador estable del dominio (gobierno)NameVARCHARNoUNIQUEAnexo D (nombre de dominio)DescriptionTEXTSí—Anexo DDomainTypeENUMNo(CLOSED, SEMI_CLOSED)Anexo D (cerrado/semi-cerrado)IsActiveBOOLNodefault trueGobiernoCreatedAt/ByauditNo—Trazabilidad LESRegla dura:R9: DomainType obliga el comportamiento de incorporación de valores (ver R12).DomainValueCampoTipo sugeridoNuloConstraintFuenteDomainValueIdUUID/BIGINTNoPKAnexo DDomainIdFKNoFK→DomainAnexo DCodeVARCHARSíUNIQUE(DomainId, Code)Gobierno (opcional pero recomendado)ValueVARCHARNoUNIQUE(DomainId, Value)Anexo D (valores)SortOrderINTSí—UX (orden estable)IsActiveBOOLNodefault trueNo borrar físicoCreatedAt/ByauditNo—TrazabilidadSourceENUMSí(NORMATIVE, USER_ADDED)Para semi-cerradosJustificationTEXTSí—Obligatoria si USER_ADDED en semi-cerradoReglas duras:R10: UNIQUE(DomainId, Value) para evitar duplicados en un mismo dominio.R11: Si Source = USER_ADDED entonces Justification NOT NULL.2) Enlace con Attribute (cerramos el círculo A3 ↔ A4)Recordatorio de A3:Si Attribute.DataType = LIST ⇒ Attribute.DomainId NOT NULL.Ahora queda reforzado con integridad referencial:Attribute.DomainId FK→Domain.DomainId.Regla dura reforzada:R7 (reafirmada): No puede existir un atributo LIST sin un dominio asignado (y viceversa: un dominio puede existir sin atributos aún, por gobierno).3) Mecanismo “semi-cerrado” (gobierno + trazabilidad)Aquí hay una decisión de implementación que NO cambia el anexo, solo lo hace ejecutable.Opción recomendada (sin ambigüedad): DomainValueRequestPermite incorporar valores en semi-cerrados con flujo de aprobación y auditoría.DomainValueRequestCampoTipoNuloReglaRequestIdPKNo—DomainIdFKNo—ProposedValueVARCHARNo—JustificationTEXTNoobligatoriaRequestedByUserIdFKNo—RequestedAtDATETIMENo—StatusENUMNo(PENDING, APPROVED, REJECTED)ReviewedByUserIdFKSísi aprobado/rechazadoReviewedAtDATETIMESísi aprobado/rechazadoDecisionNoteTEXTSíopcionalRegla dura:R12: Solo se puede aprobar una solicitud si Domain.DomainType = SEMI_CLOSED.R13: Al aprobar, se crea DomainValue con Source = USER_ADDED y Justification copiada.Esto implementa literalmente “semi-cerrado con control y trazabilidad”, sin permitir que el usuario “meta cualquier cosa” silenciosamente.Impacto UX (mínimo, derivado y visible)En campos LISTA:Si dominio CLOSED: solo selección de valores existentes; no aparece “añadir nuevo”.Si dominio SEMI_CLOSED: aparece opción “Proponer nuevo valor” y obliga a justificación (y queda pendiente/aprobado según rol).Entregables A4 (lo que queda “cerrado” técnicamente)Esquema de tablas: Domain, DomainValue, (recomendado) DomainValueRequest.Reglas de integridad: R9–R13 (cerrado/semi-cerrado, unicidad, justificación).Enlace garantizado con Attribute (LIST → Domain).Fase A5 — Asignación de atributos por subcategoría + reglas (Anexo C)Decisión funcional (normativa)Para cada Subcategoría, el Anexo C define:qué atributos aplican,su obligatoriedad (O / OP / C / NA),y las reglas condicionales (p. ej. “si X=Sí, entonces Y obligatorio/visible”).Esta asignación es el único mecanismo válido para construir la ficha dinámica (no se decide en UX ni en desarrollo “a criterio”).Cambiar la subcategoría implica revalidar la ficha (atributos que pasan a NA deben quedar sin efecto; atributos nuevos deben cumplimentarse si son O/OP).Implicación técnica (hacer el Anexo C “ejecutable”)Aquí se materializa el “cerebro” normativo. Lo separo en 2 piezas:Asignación base Subcategoría ↔ Atributo (qué aplica y cómo)Reglas condicionales (cuándo algo pasa a ser obligatorio/visible/permitido)1) Asignación base: SubcategoryAttributeRuleTabla SubcategoryAttributeRuleCampoTipo sugeridoNuloConstraintFuenteSubcategoryIdFKNoFK→SubcategoryAnexo CAttributeIdFKNoFK→AttributeAnexo CApplicabilityENUMNo(O, OP, C, NA)Anexo CDisplayOrderINTSí—Orden estable de ficha (si el anexo lo define; si no, se define una vez y se gobierna)IsVisibleByDefaultBOOLNodefault truePara atributos NA o condicionalesIsEditableBOOLNodefault trueGobierno (ej. campos calculados)GroupCodeVARCHARSí—Sección (p.ej. “Materiales”, “Piedras”, “Personalización”)CreatedAt/ByauditNo—TrazabilidadClave primaria recomendada:PK(SubcategoryId, AttributeId) (un atributo solo puede tener una regla base por subcategoría).Reglas duras asociadasR14: Si Applicability = NA entonces el sistema no debe permitir persistir valores para ese atributo en esa subcategoría (se controla en A6).R15: Si Applicability = O, el motor de validación debe exigir valor siempre (independiente de condiciones).R16: Si Applicability = OP, el motor de validación debe exigir valor solo si se cumple el “contexto operativo” definido (esto se representará como regla condicional tipo “operational condition”).R17: Si Applicability = C, el motor de validación decide obligatoriedad/visibilidad en función de condiciones.Nota importante de gobierno: si Anexo C ya trae orden y agrupación, se carga tal cual. Si no trae orden explícito, el orden se gobierna como metadato UX pero no altera obligatoriedad/reglas (es una decisión de presentación, no funcional).2) Reglas condicionales: SubcategoryRule + condiciones ejecutablesProblema a resolver (sin creatividad)El anexo describe reglas del tipo:“Si Grabado=Sí ⇒ TextoGrabado obligatorio y visible”“Si Piedra=Sí ⇒ TipoPiedra obligatorio”“Si Origen=Compra a cliente ⇒ Datos de compra obligatorios”, etc.Necesitamos un formato que:sea determinista,sea validable por BD/servicio,y no requiera interpretación humana.Modelo recomendado: reglas “IF / THEN” normalizadasTabla SubcategoryRuleCampoTipoNuloConstraintRuleIdPKNo—SubcategoryIdFKNoFK→SubcategoryRuleNameVARCHARNo—RuleTypeENUMNo(REQUIRED, VISIBLE, ALLOWED, DERIVED)PriorityINTNoorden de evaluaciónIsActiveBOOLNodefault trueCreatedAt/ByauditNo—Tabla RuleConditionRepresenta el “IF”.CampoTipoNuloConstraintRuleIdFKNoFK→SubcategoryRuleLeftAttributeIdFKNoFK→AttributeOperatorENUMNo(EQ, NEQ, IN, NOT_IN, GT, GTE, LT, LTE, IS_SET, NOT_SET)RightValueTypeENUMNo(CONST, DOMAIN_VALUE, ATTRIBUTE)RightConstValueVARCHARSísi RightValueType=CONSTRightDomainValueIdFKSísi RightValueType=DOMAIN_VALUERightAttributeIdFKSísi RightValueType=ATTRIBUTELogicGroupINTNoagrupar AND/OR (ver nota)LogicOpENUMNo(AND, OR)Nota técnica: para evitar complejidad, se usa un esquema de grupos: condiciones con mismo LogicGroup se evalúan con AND, y los grupos se combinan con OR (forma normal disyuntiva). Es ejecutable y suficiente para la mayoría de reglas de anexos.Tabla RuleActionRepresenta el “THEN”.CampoTipoNuloConstraintRuleIdFKNoFK→SubcategoryRuleTargetAttributeIdFKNoFK→AttributeActionTypeENUMNo(SET_REQUIRED, SET_OPTIONAL, SET_VISIBLE, SET_HIDDEN, SET_NOT_APPLICABLE, SET_READONLY)ActionValueVARCHARSí(si aplica)Reglas duras asociadasR18: Toda RuleAction.TargetAttributeId debe existir como atributo asignado a la subcategoría (en SubcategoryAttributeRule).Evita “reglas flotantes” que referencien atributos no aplicables.R19: Una regla SET_NOT_APPLICABLE prevalece sobre cualquier otra acción (NA manda), salvo reglas de migración de datos explícitas.R20: Si una regla hace SET_REQUIRED, debe existir una forma válida de introducir valor (datatype correcto + dominio disponible si LIST).Impacto UX (mínimo, derivado)La UX puede mostrar/hide/obligar campos sin ambigüedad porque cada condición y acción está formalizada.Al cambiar SubcategoryId, se recalcula:qué atributos quedan NA,cuáles pasan a requeridos,y cuáles deben vaciarse por integridad.Entregables A5SubcategoryAttributeRule (asignación base) con PK compuesta.SubcategoryRule + RuleCondition + RuleAction (reglas ejecutables).Conjunto de reglas de integridad R14–R20.Fase A6 — Persistencia de valores por pieza + enforcement de reglas (A3–A5)Decisión funcional (normativa)La ficha de una pieza se construye a partir de:Clasificación (Categoría/Subcategoría) (Anexo A),Catálogo de atributos (Anexo B),Reglas por subcategoría (Anexo C),Dominios/valores (Anexo D).No se permite persistir “datos sueltos”: solo atributos definidos y solo si aplican a la subcategoría.Las listas deben respetar dominio; en semi-cerrados, valores añadidos deben estar controlados y trazados.Implicación técnica (modelo de almacenamiento + validación dura)Decisión técnica clave (implementación, sin reinterpretar anexos)Para soportar ficha dinámica (múltiples subcategorías, atributos cambiantes) sin crear una tabla por subcategoría, la opción estándar y gobernable es:✅ EAV gobernado: ItemAttributeValue + enforcement por reglas A5.Esta decisión no simplifica ni cambia el modelo; lo hace implementable con crecimiento controlado.1) Tabla de valores: ItemAttributeValueItemAttributeValueCampoTipo sugeridoNuloConstraintFuenteItemAttributeValueIdUUID/BIGINTNoPKImplementación A6ItemIdFKNoFK→InventoryItemNúcleo A1AttributeIdFKNoFK→AttributeAnexo BValueTextTEXTSí—DataType=TEXTValueNumberDECIMALSí—DataType=NUMBERValueBooleanBOOLSí—DataType=BOOLEANDomainValueIdFKSíFK→DomainValueDataType=LIST (Anexo D)ValueDateDATE/DATETIMESí—DataType=DATERangeMinDECIMALSí—DataType=RANGERangeMaxDECIMALSí—DataType=RANGECreatedAt/ByauditNo—TrazabilidadUpdatedAt/ByauditNo—TrazabilidadRestricciones estructurales obligatoriasR21 (unicidad): UNIQUE(ItemId, AttributeId)Una pieza solo puede tener un valor “actual” por atributo (si se requiere historial, se resuelve con tabla de histórico, ver más abajo).R22 (integridad por tipo): exactamente un “slot de valor” debe estar informado según Attribute.DataType:TEXT ⇒ ValueText informado, resto nullNUMBER ⇒ ValueNumber informado…LIST ⇒ DomainValueId informado…RANGE ⇒ RangeMin/RangeMax informados…R23 (dominio correcto): si DomainValueId informado, debe pertenecer al DomainId del atributo:DomainValue.DomainId = Attribute.DomainIdR22 y R23 se suelen implementar como constraints + lógica de servicio, porque cruzan tablas (Attribute). Aun así, se especifican como “reglas duras” del contrato.2) Enforcement de aplicabilidad (O/OP/C/NA) y reglas condicionales (A5)Regla troncalR24 (no NA): no se permite guardar ItemAttributeValue si para la subcategoría de la pieza el atributo es NA, considerando además reglas condicionales que puedan marcarlo como NA.Cómo se evalúa aplicabilidad (sin interpretación)Para un InventoryItem:Se obtiene SubcategoryIdSe cargan reglas base SubcategoryAttributeRule (A5.1)Se cargan reglas condicionales SubcategoryRule y se evalúan con los valores actuales (A5.2)Se obtiene el estado efectivo del atributo:visible / hiddenrequired / optionalapplicable / not applicableReglas duras de validación por obligatoriedadR25 (O): todo atributo con obligatoriedad efectiva = REQUIRED debe tener valor válido (por tipo y dominio).R26 (OP): REQUIRED si se cumple condición operativa definida (queda modelada como regla condicional que hace SET_REQUIRED).R27 (C): su obligatoriedad depende de reglas; si ninguna regla lo hace required, queda optional.R28 (subcategoría cambia):si un atributo pasa a NA ⇒ sus valores deben invalidarse (ver estrategia abajo)3) Estrategia para cambios de subcategoría (revalidación y datos existentes)Aquí se fija una decisión técnica con impacto directo en integridad:Opción recomendada (segura y trazable)No borrar físico valores antiguos; se marcan como no vigentes.Tabla ItemAttributeValueHistory (o versionado en la misma tabla)Para cumplir “dato nace una vez” y mantener trazabilidad, se introduce histórico.ItemAttributeValueHistoryHistoryId PKItemIdAttributeIdValor (mismos slots que la tabla actual o JSON normalizado)ValidFrom, ValidToChangedBy, ChangedAtChangeReason (por qué cambió: “cambio subcategoría”, “corrección”, etc.)Reglas:R29: en ItemAttributeValue queda solo el valor vigente.R30: toda modificación mueve el valor anterior a histórico.Esto evita perder datos y permite auditoría real (clave LES).4) Integridad para semi-cerrados (A4) aplicada al datoR31: si un atributo es LIST y su dominio es CLOSED, no se puede almacenar un valor fuera de DomainValue.R32: si el dominio es SEMI_CLOSED y el usuario propone un valor nuevo:debe existir DomainValueRequest aprobado,y solo entonces se crea DomainValue (Source=USER_ADDED) y se puede referenciar.Impacto UX (mínimo, derivado)La ficha se construye consultando:reglas A5 para saber qué mostrar/obligar,y ItemAttributeValue para rellenar.Al guardar:el sistema valida “NA / required / dominio / tipo” antes de persistir.Si cambia subcategoría:se ejecuta revalidación y se marcan no vigentes los valores que pasan a NA (con histórico).Entregables A6Diseño de ItemAttributeValue (EAV gobernado) + R21–R23.Motor de validación (contrato) + R24–R28.Estrategia de histórico (recomendado) + R29–R30.Enforcement de semi-cerrados + R31–R32.Fase A7 — Movimientos, estados, ubicación y auditoría operacional (trazabilidad obligatoria)Decisión funcional (normativa)El inventario es troncal y la pieza mantiene trazabilidad completa: cualquier cambio operativo relevante debe quedar registrado como movimiento/evento (quién, cuándo, qué cambió, por qué y con qué documento).La pieza tiene estado operativo actual y ubicación actual, pero el detalle de “cómo llegó ahí” se expresa en el historial de movimientos.Hay operaciones típicas de inventario: alta, entrada/salida, traslado entre tiendas, reserva/apartado, entrega, venta, devolución, envío a taller/retorno, regularizaciones.Nota: aquí “movimiento” cubre tanto cambios físicos (ubicación) como cambios operativos (estado), según el RF del módulo inventario.Implicación técnica1) Catálogos operativos mínimosMovementTypeDefine tipos de movimiento (configurable, no hardcode).CampoTipoNuloConstraintMovementTypeIdPKNo—CodeVARCHARNoUNIQUENameVARCHARNoUNIQUEDescriptionTEXTSí—IsActiveBOOLNodefault trueEjemplos típicos (a cargar desde RF): CREATE, TRANSFER, STATUS_CHANGE, RESERVE, UNRESERVE, SEND_TO_WORKSHOP, RETURN_FROM_WORKSHOP, SALE, DELIVERY, RETURN, ADJUSTMENT.DocumentType (si aplica desde otros módulos)Venta, Encargo, Reparación, Garantía, Empeño/Contrato, Ajuste, etc. (En A7 solo definimos estructura, sin inventar el catálogo completo).2) Tabla central: InventoryMovementInventoryMovementCampoTipo sugeridoNuloConstraintFuenteMovementIdUUID/BIGINTNoPKRF-INV-040+ItemIdFKNoFK→InventoryItemNúcleo inventarioMovementTypeIdFKNoFK→MovementTypeRF-INV-040+FromLocationIdFKSíFK→LocationSi aplicaToLocationIdFKSíFK→LocationSi aplicaFromStatusIdFKSíFK→OperationalStatusSi aplicaToStatusIdFKSíFK→OperationalStatusSi aplicaMovementAtDATETIMENo—TrazabilidadPerformedByUserIdFKNoFK→AppUserTrazabilidadReasonCodeVARCHARSí—Gobierno (motivos estándar)ReasonNoteTEXTSí—Si requiere explicaciónDocumentTypeIdFKSí—Vinculación documentalDocumentIdVARCHAR/UUIDSí—Referencia externaCreatedAtDATETIMENodefault NOWAuditoríaCreatedByUserIdFKNo—AuditoríaReglas duras sobre coherencia del movimientoR33 (movimiento mínimo): Un movimiento debe cambiar algo:o ubicación (FromLocationId != ToLocationId)o estado (FromStatusId != ToStatusId)o amboso ser CREATE (alta) con ToLocationId y ToStatusId obligatorios.R34 (ubicación obligatoria efectiva):Para movimientos de traslado/entrada/salida debe existir ToLocationId.R35 (estado obligatorio efectivo):Para movimientos de cambio de estado debe existir ToStatusId.R36 (consistencia “from” con situación actual):FromLocationId y FromStatusId deben coincidir con los valores actuales de InventoryItem en el momento de registrar el movimiento (evita saltos).Se implementa en servicio/trigger transaccional.3) Actualización del “estado actual” en InventoryItem (sin cambios directos)Regla de oro (LES)No se actualiza InventoryItem.LocationId ni InventoryItem.OperationalStatusId directamente.Se actualizan solo como resultado de un InventoryMovement válido.Implementación:Transacción:leer InventoryItem actualvalidar From*insertar InventoryMovementactualizar InventoryItem.LocationId y/o OperationalStatusId con To*actualizar InventoryItem.LastMovementAtTodo en una única transacción atómica.Reglas duras:R37 (inmutabilidad operativa): cualquier cambio de LocationId / OperationalStatusId debe tener MovementId asociado (en DB o servicio).R38 (LastMovementAt): se actualiza desde el timestamp del último movimiento (no editable manualmente).Nota: LastMovementAt aparece en atributos comunes (Anexo B), pero aquí se trata como campo troncal derivado por historial. Se mapeará al catálogo de atributos como “derivado / read-only”.4) Reserva / apartado / bloqueo (coherencia con estados)Para evitar incoherencias del tipo “reservada en una tienda pero ubicada en otra”:Los estados y ubicaciones deben estar gobernados por dominios (A4) y su semántica se refuerza con reglas:R39: si estado = RESERVED, debe existir referencia documental o cliente (se conecta con CRM/ventas; aquí dejamos el hook DocumentType/DocumentId).R40: si estado = SOLD, la pieza queda “cerrada” y solo admite movimientos de devolución/regularización según RF.(No invento más reglas si no están en RF; dejo la estructura para encajarlas al detalle cuando aterricemos todos los RF de movimientos.)Impacto UX (mínimo, derivado)Las acciones de usuario “Cambiar ubicación” o “Marcar como reservada” son formularios de movimiento, no edición de ficha.En la ficha se muestra:estado y ubicación actuales (desde InventoryItem)historial (desde InventoryMovement) ordenado por fechay documento asociado cuando aplique.Entregables A7InventoryMovement + catálogos MovementType (+ estructura DocumentRef).Reglas R33–R40 (coherencia, transaccionalidad, prohibición de cambios directos).Definición de actualización atómica de InventoryItem (estado/ubicación/lastMovement).Fase A8 — Contrato técnico final (consolidación A1–A7) + checklist implementableA8 no añade funcionalidad “nueva”: consolida todo lo anterior en un paquete para desarrollo sin interpretación, con trazabilidad a anexos A–D y RF/FRaD del módulo Inventario.1) Decisión funcional (resumen normativo)Una pieza nace una vez (ID único no reutilizable) y se identifica también por Código + QR.La pieza se clasifica por Categoría/Subcategoría (Anexo A), y esa subcategoría gobierna la ficha dinámica.Los atributos se definen una sola vez (Anexo B) y su aplicabilidad/obligatoriedad depende de (Anexo C).Los valores de lista vienen de dominios controlados (Anexo D), con control adicional en semi-cerrados.Estado/Ubicación actuales existen en la pieza, pero todo cambio operativo queda trazado mediante movimientos.2) ERD consolidado (texto)2.1 Núcleo de inventarioInventoryItemFK→OperationalStatusFK→LocationFK→CategorySubcategory (o Category+Subcategory con validación de consistencia)audit FK→AppUser2.2 Catálogos de clasificaciónCategorySubcategory (FK→Category)CategorySubcategory (PK compuesta CategoryId+SubcategoryId)2.3 Catálogo de atributos y dominiosAttribute (opcional FK→Domain)DomainDomainValue(recomendado) DomainValueRequest (solo para SEMI_CLOSED)2.4 Reglas por subcategoríaSubcategoryAttributeRule (PK compuesta SubcategoryId+AttributeId)SubcategoryRuleRuleConditionRuleAction2.5 Datos dinámicos de la piezaItemAttributeValue (UNIQUE ItemId+AttributeId)(recomendado) ItemAttributeValueHistory (auditoría/versionado)2.6 Auditoría operativaMovementTypeInventoryMovement (FK→Item, MovementType, From/To Status, From/To Location, DocumentRef opcional)3) Diccionario técnico mínimo (por tabla)InventoryItem (campos troncales)ItemId PKItemCode UNIQUEQRValue UNIQUEOperationalStatusId NOT NULL FKLocationId NOT NULL FKCategoryId, SubcategoryId (o FK compuesta a CategorySubcategory) NOT NULLLastMovementAt (derivado, read-only)CreatedAt/By, UpdatedAt/ByAttributeAttributeId PKName UNIQUEDataType (TEXT/NUMBER/BOOLEAN/LIST/RANGE/DATE)DomainId FK nullable (obligatorio si LIST)ItemAttributeValueItemAttributeValueId PKItemId FK NOT NULLAttributeId FK NOT NULLslots por tipo (uno y solo uno activo)DomainValueId FK cuando LIST (y consistente con el dominio del atributo)auditInventoryMovementMovementId PKItemId FK NOT NULLMovementTypeId FK NOT NULLFrom/To location/status según tipoMovementAt, PerformedByUserIdDocumentRef opcionalReason opcional(Si quieres, el siguiente paso puede ser volcar el diccionario completo “campo a campo” por cada tabla en formato de especificación para dev.)4) Reglas de integridad (compiladas)Identidad y núcleoR1: PK ItemId único no reutilizable.R1b: ItemCode UNIQUE; QRValue UNIQUE.R2: OperationalStatusId y LocationId obligatorios.ClasificaciónR4: CategoryId y SubcategoryId obligatorios.R5: consistencia Category↔Subcategory garantizada (FK compuesta o validación).Atributos y dominiosR6: Attribute.Name único global.R7: si DataType=LIST ⇒ DomainId obligatorio; si no ⇒ null.R10: UNIQUE(DomainId, Value) en DomainValue.R11/R12: semi-cerrado exige justificación y flujo controlado.Reglas por subcategoría (Anexo C ejecutable)R14: NA ⇒ no persistir valor (ni vigente ni nuevo).R15–R20: O/OP/C + acciones condicionales, deterministas.Persistencia de valoresR21: UNIQUE(ItemId, AttributeId).R22: “slot de valor” único por DataType.R23: DomainValue pertenece al Domain del Attribute.R29/R30: si hay cambios, histórico/versionado (recomendado para auditoría LES).MovimientosR33–R36: un movimiento cambia algo y respeta consistencia from→to.R37: prohibido cambiar estado/ubicación sin movimiento.R38: LastMovementAt derivado del movimiento.5) Contratos mínimos de integración (sin inventar módulos)Para que Inventario sea troncal y “dato nace una vez”:InventoryItem.ItemId es la clave maestra para referencias externas (venta, reparación, encargo, empeño, etc.).InventoryMovement permite vincular cualquier evento con DocumentTypeId + DocumentId sin duplicar datos del documento (la información vive en su módulo).6) Checklist de pruebas de integridad (base para QA / Casos de prueba)Esto sirve como “suite mínima” para garantizar que lo implementado respeta anexos:IdentidadCrear 2 piezas con mismo ItemCode ⇒ debe fallar.Crear pieza sin Status/Location ⇒ debe fallar.ClasificaciónAsignar Subcategoría no perteneciente a Categoría ⇒ debe fallar.DominiosGuardar valor LIST fuera de DomainValue ⇒ debe fallar.En dominio CLOSED: intentar añadir valor nuevo ⇒ debe fallar.En dominio SEMI_CLOSED: proponer valor sin justificación ⇒ debe fallar; con justificación ⇒ queda PENDING.Reglas Anexo CAtributo NA para subcategoría: intentar guardar valor ⇒ debe fallar.Atributo O: guardar pieza sin valor ⇒ debe fallar.Condición: Grabado=Sí ⇒ TextoGrabado requerido; probar con Sí y sin texto ⇒ debe fallar.MovimientosIntentar cambiar InventoryItem.LocationId directo ⇒ debe fallar (o quedar bloqueado por capa de servicio).Crear movimiento con FromStatus distinto del estado actual ⇒ debe fallar.
