SR-01 — Alta de pieza (Create Inventory Item) + movimiento CREATE obligatorioDecisión funcionalUna pieza nace una sola vez, con código/QR, clasificación, estado y ubicación iniciales; debe quedar trazada su creación.Implicación técnicaEndpoint/Use case: POST /inventory/itemsTransacción atómica:Validar payload mínimo: category_id, subcategory_id, location_id, operational_state_id (NN).Validar coherencia category_id + subcategory_id (FK compuesta a inv_category_subcategory).Generar item_id.Generar item_code (según política) y item_qr_value (derivado de item_id).Insertar inv_item.Insertar inv_movement con event_type=CREATE, to_state_id, to_location_id, reason='CREATE'.Set inv_item.last_movement_at = movement.performed_at.Ejecutar SR-03 (validación de atributos obligatorios iniciales según subcategoría) antes de confirmar.Impacto UXWizard de alta no puede finalizar si falta clasificación/estado/ubicación o atributos obligatorios.RFRF-INV-002/003, 010–013, 030–031, 040–044, 036SR-02 — Cambio de clasificación (Category/Subcategory) = Revalidación completa + tratamiento de NADecisión funcionalCambiar subcategoría cambia la ficha dinámica; atributos que pasan a NA no deben persistir como vigentes; nuevos obligatorios deben completarse.Implicación técnicaEndpoint: PATCH /inventory/items/{id}/classificationTransacción:Validar FK compuesta (new_category_id, new_subcategory_id).Recalcular “perfil de ficha” efectivo para new_subcategory_id (ver SR-03).Comparar con valores existentes (inv_item_attribute_value):Para cada atributo que queda NA en la nueva subcategoría ⇒ invalidar vigencia:Opción recomendada: mover a histórico y borrar vigente (o marcar is_active=false si se modela).Para atributos que pasan a obligatorios efectivos y no tienen valor ⇒ devolver error con lista de campos faltantes.Actualizar inv_item.category_id/subcategory_id.Registrar inv_movement con event_type=CLASSIFICATION_CHANGE (si RF prevé; si no, al menos auditar).Impacto UXAl cambiar subcategoría, la UI debe mostrar un “paso de revisión” con:campos que desaparecen (NA),campos nuevos obligatorios,confirmación de datos que se conservarán.RFRF-INV-030/031/036 (+ reglas Anexo C)SR-03 — Motor de ficha dinámica: evaluación determinista de obligatoriedad/visibilidad (O/OP/C/NA)Decisión funcionalLa ficha se construye solo con Anexo B (atributos) + Anexo C (aplicabilidad y reglas). No hay decisiones UX libres.Implicación técnicaFunción de dominio: ComputeEffectiveAttributeRules(item_id, subcategory_id, current_values)Devuelve para cada atributo aplicable:is_applicable (true/false)is_visible (true/false)is_required (true/false)datatype, domain_id (si LIST)Algoritmo (orden):Cargar reglas base inv_subcategory_attribute (O/OP/C/NA).Inicializar:NA ⇒ not applicable, not visible, not requiredO ⇒ applicable + required + visibleOP ⇒ applicable + optional (hasta que reglas lo activen)C ⇒ applicable + optional (hasta que reglas lo activen)Evaluar reglas condicionales (si las modelas como condition_expression o como tablas normalizadas):aplicar acciones (SET_REQUIRED/SET_VISIBLE/SET_NOT_APPLICABLE/SET_READONLY)Resolver conflictos:NOT_APPLICABLE prevalece sobre todoREQUIRED prevalece sobre OPTIONALEmitir resultado final para UI y validación.Impacto UXLa UI no “adivina”: consulta este servicio para pintar la ficha y para validar antes de guardar.RFRF-INV-033/036SR-04 — Guardado de valores de atributos: tipado estricto + dominio correcto + prohibición NADecisión funcionalNo se guardan valores fuera de atributos definidos; listas deben respetar dominio; NA no se guarda; requeridos deben cumplirse.Implicación técnicaEndpoint: PUT /inventory/items/{id}/attributesValidaciones:Para cada entrada: attribute_id debe existir en inv_attribute.El atributo debe ser aplicable a la subcategoría efectiva (SR-03): si is_applicable=false ⇒ error.Validación de tipo:Si data_type=text ⇒ solo value_text permitido, resto null.Si list ⇒ domain_value_id obligatorio.Validación de dominio:domain_value.domain_id == attribute.domain_id.Validación de obligatoriedad:Ejecutar SR-03 con los valores resultantes (post-merge) y verificar todos is_required=true informados.Persistencia:Upsert por (item_id, attribute_id) garantizando UNIQUE.Impacto UXMensajes de error deben venir estructurados:attribute_id, error_code (TYPE_MISMATCH / NOT_APPLICABLE / DOMAIN_INVALID / REQUIRED_MISSING), help_text.RFRF-INV-032/033/034/035/036, 013SR-05 — Dominios semi-cerrados: propuesta de nuevo valor con justificación y controlDecisión funcionalDominios semi-cerrados permiten ampliar valores, pero con justificación y trazabilidad. 01-02 - FRaD - Anexo D - Domini…Implicación técnicaEndpoint: POST /inventory/domains/{domain_id}/requestsValidar domain.domain_type == semi_closed.proposed_value obligatorio.justification obligatorio.Crear inv_domain_value_request con status=PENDING.Aprobación: POST /inventory/domain-value-requests/{id}/approveCrea inv_domain_value con source=USER_ADDED y copia la justificación.Impacto UXEn campos lista semi-cerrados aparece “Proponer valor”.El usuario ve estado pendiente/aprobado/rechazado según rol.RFRF-INV-034/035 (política de dominio controlado)SR-06 — Cambios de estado y ubicación: solo por movimiento (no edición directa)Decisión funcionalLa ubicación/estado actuales son un “snapshot”; el cambio real se registra como movimiento.Implicación técnicaEndpoint: POST /inventory/items/{id}/movementsValidación transaccional:Leer inv_item actual (estado/ubicación).Validar from_state_id y from_location_id coinciden con el actual (si se envían; recomendado).Validar que el movimiento cambia algo (al menos to_state != from_state o to_location != from_location).Insertar inv_movement con mínimos obligatorios: item, usuario, fecha, motivo.Actualizar inv_item.operational_state_id y/o inv_item.location_id con to_*.inv_item.last_movement_at = movement.performed_at.Bloqueo:Prohibir endpoints que actualicen operational_state_id/location_id directamente.Impacto UXAcciones “Transferir”, “Enviar a taller”, “Marcar reservada”, “Recibir” son formularios de movimiento.RFRF-INV-040–044, 041, 042SR-07 — Apartado/Reserva: coherencia estado–reserva + unicidad de reserva activaDecisión funcionalUna pieza apartada debe quedar bloqueada/identificada; no puede haber dos apartados activos simultáneos.Implicación técnicaEndpoint: POST /inventory/items/{id}/reservationsValidar que inv_item no está en estado final (vendida/cerrada).Verificar no existe inv_reservation activa para ese item (UNIQUE condicional).Crear inv_reservation (customer_id, expires_at, etc.).Crear inv_movement event_type=RESERVE y llevar operational_state_id a “RESERVED”.Liberar/expirar:POST /reservations/{id}/release ⇒ movement UNRESERVE y estado vuelve a “AVAILABLE” (o el que defina RF).Impacto UXUI muestra “Reservada por X hasta fecha Y” y bloquea venta/edición según permisos.RFRF-INV-050–055 + RF-INV-040–044SR-08 — Reparación/Salida a taller: coherencia ubicación–estado–orden de reparaciónDecisión funcionalCuando una pieza sale a taller/externo, se debe trazar la orden y el movimiento.Implicación técnicaEndpoint: POST /inventory/items/{id}/repair-ordersCrear inv_repair_order (workshop, notas, status=open).Registrar movimiento SEND_TO_WORKSHOP:to_location_id = external_workshopto_state_id = IN_REPAIR (o equivalente).Al recibir: POST /repair-orders/{id}/receivemovement RETURN_FROM_WORKSHOP, actualiza estado/ubicación.Impacto UXLínea de tiempo (movimientos) + panel de “Reparación activa”.RFRF-INV-060–064 + RF-INV-040–044SR-09 — Etiquetas: impresión/reimpresión auditadaDecisión funcionalLa impresión y reimpresión debe quedar registrada (quién/cuándo/motivo), y la etiqueta debe contener identificadores (código + QR).Implicación técnicaEndpoint: POST /inventory/items/{id}/labels/printGenerar payload (snapshot) con item_code + QR + descripción.Guardar inv_label_print_log con action=print.Reprint requiere motivo si así lo marca el RF/casos de prueba.Impacto UXBotón “Reimprimir” pide motivo.RFRF-INV-090–092SR-10 — Lectura completa de ficha (Read model): composición sin duplicidadDecisión funcionalLa ficha debe poder consultarse “completa”: núcleo + atributos dinámicos + historial. 02-01 - DOCUMENTO RFImplicación técnicaEndpoint: GET /inventory/items/{id} devuelve:inv_item (core)classification (cat/subcat)attributes (valores vigentes)effective_rules (resultado SR-03 para UI)movements (historial paginado)active_reservation (si existe)active_repair_order (si existe)Impacto UXEvita múltiples llamadas y asegura que UI aplica exactamente reglas del sistema.RFRF-INV-013/036/040–044Paquete final de “reglas de servicio” (resumen ejecutable)Alta = item + movimiento CREATE (SR-01)Cambio subcategoría = revalidación + NA (SR-02)Motor de reglas determinista (SR-03)Guardado tipado + dominio + requeridos + NA (SR-04)Semi-cerrados con solicitud y justificación (SR-05)Estado/ubicación solo por movimientos (SR-06)Reserva coherente + unicidad activa (SR-07)Reparación coherente + movimientos (SR-08)Etiquetas con auditoría (SR-09)Read model de ficha completa (SR-10)
